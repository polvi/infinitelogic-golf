---
export interface Props {
	query: string;
}

const { query } = Astro.props;
---

<div id="streaming-container" data-query={query}>
	<div class="loading">Generating response...</div>
</div>

<script>
	async function streamResponse() {
		console.log('Client: Starting stream response');
		const container = document.getElementById('streaming-container');
		const query = container?.getAttribute('data-query');
		
		if (!query || !container) {
			console.log('Client: Missing query or container');
			return;
		}

		try {
			console.log('Client: Calling API with query:', query);
			// Call AutoRAG streaming endpoint
			const response = await fetch('/api/stream', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({ query }),
			});

			console.log('Client: Got API response:', response.status);
			if (!response.ok) {
				throw new Error(`HTTP ${response.status}: ${response.statusText}`);
			}

			if (!response.body) {
				console.log('Client: No response body');
				throw new Error('No response body');
			}

			console.log('Client: Setting up stream processing');
			// Clear loading message and create response div
			container.innerHTML = '<div class="streaming-response"></div>';
			const responseDiv = container.querySelector('.streaming-response');
			
			const reader = response.body
				.pipeThrough(new TextDecoderStream())
				.getReader();
			
			let buffer = '';
			let accumulatedText = '';
			
			try {
				while (true) {
					const { done, value } = await reader.read();
					console.log('Client: Read chunk:', { done, valueLength: value?.length });
					if (done) {
						if (buffer.trim()) {
							console.warn('Stream ended with unparsed data:', buffer);
						}
						break;
					}
					
					console.log('Client: Raw value:', value);
					buffer += value;
					const lines = buffer.split('\n');
					buffer = lines.pop() || '';
					
					for (const line of lines) {
						console.log('Client: Processing line:', line);
						if (line.startsWith('data: ')) {
							const data = line.slice(6).trim();
							if (data === '[DONE]') break;
							
							try {
								console.log('Client: Processing data line:', data);
								const jsonData = JSON.parse(data);
								if (jsonData.response) {
									console.log('Client: Got response chunk:', jsonData.response);
									accumulatedText += jsonData.response;
									if (responseDiv) {
										responseDiv.textContent = accumulatedText;
										responseDiv.scrollTop = responseDiv.scrollHeight;
									}
								}
							} catch (parseError) {
								console.warn('Error parsing JSON:', parseError, 'Data:', data);
							}
						}
					}
				}
			} finally {
				reader.releaseLock();
			}
		} catch (error) {
			console.error('AutoRAG Streaming error:', error);
			container.innerHTML = `<div class="error">Error: ${error.message}</div>`;
		}
	}

	// Start streaming when the component loads
	streamResponse();
</script>

<style>
	.streaming-response {
		background: white;
		border: 1px solid #ddd;
		border-radius: 4px;
		padding: 15px;
		min-height: 100px;
		max-height: 400px;
		overflow-y: auto;
		white-space: pre-wrap;
		font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
		line-height: 1.6;
		animation: fadeIn 0.3s ease-in;
	}
	
	.loading {
		color: #666;
		font-style: italic;
		padding: 15px;
	}
	
	.error {
		color: #d32f2f;
		background: #ffebee;
		padding: 10px;
		border-radius: 4px;
	}
	
	@keyframes fadeIn {
		from { opacity: 0; }
		to { opacity: 1; }
	}
</style>
