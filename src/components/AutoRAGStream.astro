---
export interface Props {
	query: string;
}

const { query } = Astro.props;
---

<div id="streaming-container" data-query={query}>
	<div class="loading">Generating response...</div>
</div>

<script>
	import * as smd from "streaming-markdown";
	async function streamResponse() {
		const container = document.getElementById('streaming-container');
		const query = container?.getAttribute('data-query');
		
		if (!query || !container) {
			return;
		}

		try {
			// Call AutoRAG streaming endpoint
			const response = await fetch('/api/stream', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({ query }),
			});

			if (!response.ok) {
				throw new Error(`HTTP ${response.status}: ${response.statusText}`);
			}

			if (!response.body) {
				throw new Error('No response body');
			}
			// Clear loading message and create response div
			container.innerHTML = '<div class="streaming-response"></div>';
			const responseDiv = container.querySelector('.streaming-response');
			
			// Initialize markdown parser
			const renderer = smd.default_renderer(responseDiv);
			const markdownParser = smd.parser(renderer);
			
			const reader = response.body
				.pipeThrough(new TextDecoderStream())
				.getReader();
			
			let buffer = '';
			
			try {
				while (true) {
					const { done, value } = await reader.read();
					if (done) {
						if (buffer.trim()) {
							console.warn('Stream ended with unparsed data:', buffer);
						}
						smd.parser_end(markdownParser);
						break;
					}
					
					buffer += value;
					const lines = buffer.split('\n');
					buffer = lines.pop() || '';
					
					for (const line of lines) {
						if (line.startsWith('data: ')) {
							const data = line.slice(6).trim();
							if (data === '[DONE]') {
								smd.parser_end(markdownParser);
								break;
							}
							
							try {
								const jsonData = JSON.parse(data);
								if (jsonData.response) {
									smd.parser_write(markdownParser, jsonData.response);
									if (responseDiv) {
										responseDiv.scrollTop = responseDiv.scrollHeight;
									}
								}
							} catch (parseError) {
								console.warn('Error parsing JSON:', parseError, 'Data:', data);
							}
						}
					}
				}
			} finally {
				reader.releaseLock();
			}
		} catch (error) {
			console.error('AutoRAG Streaming error:', error);
			container.innerHTML = `<div class="error">Error: ${error.message}</div>`;
		}
	}

	// Start streaming when the component loads
	streamResponse();
</script>

<style>
	.streaming-response {
		background: white;
		border: 1px solid #ddd;
		border-radius: 4px;
		padding: 15px;
		min-height: 100px;
		max-height: 400px;
		overflow-y: auto;
		white-space: pre-wrap;
		font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
		line-height: 1.6;
		animation: fadeIn 0.3s ease-in;
	}
	
	.loading {
		color: #666;
		font-style: italic;
		padding: 15px;
	}
	
	.error {
		color: #d32f2f;
		background: #ffebee;
		padding: 10px;
		border-radius: 4px;
	}
	
	@keyframes fadeIn {
		from { opacity: 0; }
		to { opacity: 1; }
	}
</style>
